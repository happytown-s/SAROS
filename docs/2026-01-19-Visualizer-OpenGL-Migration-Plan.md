# Visualizer OpenGL Migration Plan

## 1. 概要
現在の `CircularVisualizer` (`juce::Graphics` ベース) を OpenGL (`juce::OpenGLRenderer` / GLSL) ベースに置き換えるための技術的計画書です。
OpenGL化により、描画パフォーマンスの劇的な向上と、シェーダーを用いたリッチな視覚表現（発光、ブルーム、パーティクル増量等）が可能になります。

## 2. 難易度とコスト感
ユーザーの「難しい？」という問いへの回答としては、**「難易度は高め（中級〜上級者向け）」** となります。

- **必要なスキル**: C++、JUCE APIに加え、**GLSL (シェーダー言語)** と3Dグラフィックスのパイプライン（頂点バッファ、マトリックス変換など）の理解が必要。
- **実装コスト**: 単純な置き換えではなく、描画ロジックの再構築になるため、完全な移行には数日を要する可能性があります。

## 3. 移行フェーズ案

いきなり全てを書き換えるのではなく、段階的に進めることを推奨します。

### Phase 1: OpenGLContext のアタッチ (即時導入可能)
既存の描画コード (`paint` メソッド) は書き換えずに、バックエンドのレンダリングエンジンだけを OpenGL に切り替えます。

**実装方法:**
1. モジュール `juce_opengl` をプロジェクトに追加。
2. `MainComponent` または `CircularVisualizer` に `juce::OpenGLContext openGLContext;` をメンバとして追加。
3. コンストラクタで `openGLContext.attachTo(*this);` を呼ぶ。

**メリット:**
- 最も手軽（数行のコード追加）。
- CPUで行っていた描画計算の一部がGPUにオフロードされ、UI全体のレスポンスが向上する可能性がある。

**デメリット:**
- JUCEの `Graphics` コマンドをOpenGL命令に変換するオーバーヘッドがあるため、複雑なパス描画（現在の実装のような多重線描画）の場合、逆に遅くなるケースがある。

### Phase 2: ハイブリッド描画 & シェーダー導入 (推奨)
背景や「光る波形」「背景のパーティクル」など、負荷が高くエフェクトが必要な部分だけを OpenGL (GLSLシェーダー) で描き、テキストやUIパーツは既存の `juce::Graphics` で上書きします。

**実装アプローチ:**
`juce::OpenGLRenderer` を継承し、`renderOpenGL()` メソッド内で以下の順で描画します。

1. **背景・エフェクト (GLSL)**: シェーダーでクールな背景や全体の発光処理を描画。
2. **波形 (VBO)**: 波形データを頂点バッファとしてGPUに転送し、高速描画。
3. **JUCE Graphics (Overlay)**: 従来通り `paint()` を呼び出し、文字などを上に重ねる。

### Phase 3: フルネイティブ OpenGL 化
全ての描画を OpenGL ネイティブで行います。

**実装アプローチ:**
- **波形 (Waveforms)**:
    - 現状: `juce::Path` を `g.strokePath` で複数回重ね書きしてグローを表現。
    - OpenGL: 波形データを **VBO (Vertex Buffer Object)** に毎フレーム転送し、`GL_LINE_STRIP` で描画。
    - **グロー表現**: ジオメトリシェーダーで線を太らせる、またはポストプロセス（ブルームフィルタ）を使用して、ピクセルシェーダーで美しい発光を実現。CPU負荷はほぼゼロになります。
- **パーティクル**:
    - 現状: CPUで座計算し、個別に円を描画。数が増えると重い。
    - OpenGL: **ポイントスプライト (Point Sprites)** またはインスタンシング描画を使用。数千〜数万個のパーティクルを60fpsで描画可能。

## 4. メリット・デメリット比較

| 項目               | juce::Graphics (現状)              | OpenGL (移行後)                                        |
| :----------------- | :--------------------------------- | :----------------------------------------------------- |
| **表現力**         | 標準的。複雑な光の表現は重い。     | **無限大**。ネオン、歪み、流体表現などが容易かつ美麗。 |
| **パフォーマンス** | CPU依存。要素数が増えるとfps低下。 | GPU依存。**安定して60fps以上**が可能。                 |
| **保守性**         | コードが直感的で読みやすい。       | シェーダーコード管理、状態管理など複雑化する。         |
| **拡張性**         | 限界がある。                       | ポストプロセス等で後から見た目を大きく変えられる。     |

## 5. 推奨ステップ

1. まず **Phase 1** を試し、現状のコードのまま `OpenGLContext` をアタッチしてパフォーマンスの変化を見る。
2. もし重い場合や、よりリッチな見た目（本物の発光表現など）を目指すなら、**Phase 2** へ進み、波形描画部分からシェーダー化する。

SAROSのような「サイバーパンク / ネオン」な世界観には、OpenGL（特にシェーダーによるブルーム効果）は**非常に相性が良い**です。難易度はありますが、挑戦する価値は十分にあります。
